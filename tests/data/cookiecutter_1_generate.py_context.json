{
    "2": "\"\"\"Functions for generating a project from a project template.\"\"\"\nimport fnmatch\nimport json\nimport logging\nimport os",
    "3": "\"\"\"Functions for generating a project from a project template.\"\"\"\nimport fnmatch\nimport json\nimport logging\nimport os\nimport shutil",
    "4": "\"\"\"Functions for generating a project from a project template.\"\"\"\nimport fnmatch\nimport json\nimport logging\nimport os\nimport shutil\nfrom collections import OrderedDict",
    "5": "import fnmatch\nimport json\nimport logging\nimport os\nimport shutil\nfrom collections import OrderedDict\n",
    "6": "import json\nimport logging\nimport os\nimport shutil\nfrom collections import OrderedDict\n\nfrom binaryornot.check import is_binary",
    "7": "import logging\nimport os\nimport shutil\nfrom collections import OrderedDict\n\nfrom binaryornot.check import is_binary\nfrom jinja2 import FileSystemLoader",
    "9": "import shutil\nfrom collections import OrderedDict\n\nfrom binaryornot.check import is_binary\nfrom jinja2 import FileSystemLoader\nfrom jinja2.exceptions import TemplateSyntaxError, UndefinedError\n",
    "10": "from collections import OrderedDict\n\nfrom binaryornot.check import is_binary\nfrom jinja2 import FileSystemLoader\nfrom jinja2.exceptions import TemplateSyntaxError, UndefinedError\n\nfrom cookiecutter.environment import StrictEnvironment",
    "11": "\nfrom binaryornot.check import is_binary\nfrom jinja2 import FileSystemLoader\nfrom jinja2.exceptions import TemplateSyntaxError, UndefinedError\n\nfrom cookiecutter.environment import StrictEnvironment\nfrom cookiecutter.exceptions import (",
    "13": "from jinja2 import FileSystemLoader\nfrom jinja2.exceptions import TemplateSyntaxError, UndefinedError\n\nfrom cookiecutter.environment import StrictEnvironment\nfrom cookiecutter.exceptions import (\n    ContextDecodingException,\n    FailedHookException,",
    "14": "from jinja2.exceptions import TemplateSyntaxError, UndefinedError\n\nfrom cookiecutter.environment import StrictEnvironment\nfrom cookiecutter.exceptions import (\n    ContextDecodingException,\n    FailedHookException,\n    NonTemplatedInputDirException,",
    "15": "\nfrom cookiecutter.environment import StrictEnvironment\nfrom cookiecutter.exceptions import (\n    ContextDecodingException,\n    FailedHookException,\n    NonTemplatedInputDirException,\n    OutputDirExistsException,",
    "16": "from cookiecutter.environment import StrictEnvironment\nfrom cookiecutter.exceptions import (\n    ContextDecodingException,\n    FailedHookException,\n    NonTemplatedInputDirException,\n    OutputDirExistsException,\n    UndefinedVariableInTemplate,",
    "17": "from cookiecutter.exceptions import (\n    ContextDecodingException,\n    FailedHookException,\n    NonTemplatedInputDirException,\n    OutputDirExistsException,\n    UndefinedVariableInTemplate,\n)",
    "18": "    ContextDecodingException,\n    FailedHookException,\n    NonTemplatedInputDirException,\n    OutputDirExistsException,\n    UndefinedVariableInTemplate,\n)\nfrom cookiecutter.find import find_template",
    "19": "    FailedHookException,\n    NonTemplatedInputDirException,\n    OutputDirExistsException,\n    UndefinedVariableInTemplate,\n)\nfrom cookiecutter.find import find_template\nfrom cookiecutter.hooks import run_hook",
    "20": "    NonTemplatedInputDirException,\n    OutputDirExistsException,\n    UndefinedVariableInTemplate,\n)\nfrom cookiecutter.find import find_template\nfrom cookiecutter.hooks import run_hook\nfrom cookiecutter.utils import make_sure_path_exists, rmtree, work_in",
    "21": "    OutputDirExistsException,\n    UndefinedVariableInTemplate,\n)\nfrom cookiecutter.find import find_template\nfrom cookiecutter.hooks import run_hook\nfrom cookiecutter.utils import make_sure_path_exists, rmtree, work_in\n",
    "22": "    UndefinedVariableInTemplate,\n)\nfrom cookiecutter.find import find_template\nfrom cookiecutter.hooks import run_hook\nfrom cookiecutter.utils import make_sure_path_exists, rmtree, work_in\n\nlogger = logging.getLogger(__name__)",
    "23": ")\nfrom cookiecutter.find import find_template\nfrom cookiecutter.hooks import run_hook\nfrom cookiecutter.utils import make_sure_path_exists, rmtree, work_in\n\nlogger = logging.getLogger(__name__)\n",
    "25": "from cookiecutter.hooks import run_hook\nfrom cookiecutter.utils import make_sure_path_exists, rmtree, work_in\n\nlogger = logging.getLogger(__name__)\n\n\ndef is_copy_only_path(path, context):",
    "28": "def is_copy_only_path(path, context):\n    \"\"\"Check whether the given `path` should only be copied and not rendered.\n\n    Returns True if `path` matches a pattern in the given `context` dict,\n    otherwise False.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False",
    "38": "def is_copy_only_path(path, context):\n    \"\"\"Check whether the given `path` should only be copied and not rendered.\n\n    Returns True if `path` matches a pattern in the given `context` dict,\n    otherwise False.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False",
    "39": "def is_copy_only_path(path, context):\n    \"\"\"Check whether the given `path` should only be copied and not rendered.\n\n    Returns True if `path` matches a pattern in the given `context` dict,\n    otherwise False.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False",
    "40": "def is_copy_only_path(path, context):\n    \"\"\"Check whether the given `path` should only be copied and not rendered.\n\n    Returns True if `path` matches a pattern in the given `context` dict,\n    otherwise False.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False",
    "41": "def is_copy_only_path(path, context):\n    \"\"\"Check whether the given `path` should only be copied and not rendered.\n\n    Returns True if `path` matches a pattern in the given `context` dict,\n    otherwise False.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False",
    "42": "def is_copy_only_path(path, context):\n    \"\"\"Check whether the given `path` should only be copied and not rendered.\n\n    Returns True if `path` matches a pattern in the given `context` dict,\n    otherwise False.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False",
    "43": "def is_copy_only_path(path, context):\n    \"\"\"Check whether the given `path` should only be copied and not rendered.\n\n    Returns True if `path` matches a pattern in the given `context` dict,\n    otherwise False.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False",
    "45": "def is_copy_only_path(path, context):\n    \"\"\"Check whether the given `path` should only be copied and not rendered.\n\n    Returns True if `path` matches a pattern in the given `context` dict,\n    otherwise False.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False",
    "48": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "50": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "51": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "53": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "55": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "57": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "59": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "63": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "64": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "65": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "67": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
    "70": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "71": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "72": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "82": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "84": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "85": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "86": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "87": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "90": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "91": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "92": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "93": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "94": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "95": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "96": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "99": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "100": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "101": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "105": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "106": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "107": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "108": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "110": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "111": "def generate_context(\n    context_file='cookiecutter.json', default_context=None, extra_context=None\n):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message)\n        )\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is %s', context)\n    return context",
    "114": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "135": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "138": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "140": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "141": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "142": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "143": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "144": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "146": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "147": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "148": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "150": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "153": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "154": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "155": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "156": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "157": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "160": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "163": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "164": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "165": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "168": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "169": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "170": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "174": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "175": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "178": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "179": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "180": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "181": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "183": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "185": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "186": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "189": "def generate_file(project_dir, infile, context, env, skip_if_file_exists=False):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file %s', infile)\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: %s', outfile)\n        return\n\n    if skip_if_file_exists and os.path.exists(outfile):\n        logger.debug('The resulting file already exists: %s', outfile)\n        return\n\n    logger.debug('Created file at %s', outfile)\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check %s to see if it's a binary\", infile)\n    if is_binary(infile):\n        logger.debug('Copying binary %s to %s without rendering', infile, outfile)\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        # Detect original file newline to output the rendered file\n        # note: newline='' ensures newlines are not converted\n        with open(infile, 'r', encoding='utf-8', newline='') as rd:\n            rd.readline()  # Read the first line to load 'newlines' value\n\n            # Use `_new_lines` overwrite from context, if configured.\n            newline = rd.newlines\n            if context['cookiecutter'].get('_new_lines', False):\n                newline = context['cookiecutter']['_new_lines']\n                logger.debug('Overwriting end line character with %s', newline)\n\n        logger.debug('Writing contents to file %s', outfile)\n\n        with open(outfile, 'w', encoding='utf-8', newline=newline) as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
    "192": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "193": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "194": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "196": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "197": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "199": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "201": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "202": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "203": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "205": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "207": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "208": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "209": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "210": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "211": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "212": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "213": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "214": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "215": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "216": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "218": "def render_and_create_dir(\n    dirname, context, output_dir, environment, overwrite_if_exists=False\n):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(os.path.join(output_dir, rendered_dirname))\n\n    logger.debug(\n        'Rendered dir %s must exist in output_dir %s', dir_to_create, output_dir\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory %s already exists, overwriting it', dir_to_create\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
    "221": "def ensure_dir_is_templated(dirname):\n    \"\"\"Ensure that dirname is a templated directory name.\"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException",
    "223": "def ensure_dir_is_templated(dirname):\n    \"\"\"Ensure that dirname is a templated directory name.\"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException",
    "224": "def ensure_dir_is_templated(dirname):\n    \"\"\"Ensure that dirname is a templated directory name.\"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException",
    "225": "def ensure_dir_is_templated(dirname):\n    \"\"\"Ensure that dirname is a templated directory name.\"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException",
    "226": "def ensure_dir_is_templated(dirname):\n    \"\"\"Ensure that dirname is a templated directory name.\"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException",
    "229": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "230": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "231": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "241": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "242": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "243": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "244": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "245": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "246": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "247": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "248": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "249": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "250": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "251": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "252": "def _run_hook_from_repo_dir(\n    repo_dir, hook_name, project_dir, context, delete_project_on_failure\n):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because %s hook \"\n                \"script didn't exit successfully\",\n                hook_name,\n            )\n            raise",
    "255": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "256": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "257": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "258": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "259": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "260": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "261": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "262": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "272": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "273": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "274": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "276": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "277": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "278": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "279": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "280": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "281": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "282": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "283": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "284": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "285": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "294": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "295": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "299": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "301": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "302": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "303": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "304": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "306": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "307": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "309": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "313": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "314": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "316": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "317": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "321": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "322": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "323": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "324": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "326": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "327": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "328": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "329": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "330": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "331": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "335": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "336": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "337": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "338": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "339": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "340": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "341": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "342": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "343": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "344": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "345": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "346": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "347": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "349": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "350": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "351": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "352": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "353": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "354": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "355": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "356": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "357": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "358": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "359": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "360": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "361": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "362": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "363": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "364": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "365": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "366": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "367": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "368": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "369": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "371": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "372": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "373": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "374": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "375": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "376": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "377": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "378": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir",
    "380": "def generate_files(\n    repo_dir,\n    context=None,\n    output_dir='.',\n    overwrite_if_exists=False,\n    skip_if_file_exists=False,\n    accept_hooks=True,\n):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    :param accept_hooks: Accept pre and post hooks if set to `True`.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from %s...', template_dir)\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(context=context, keep_trailing_newline=True)\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir, context, output_dir, env, overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is %s', project_dir)\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir, 'pre_gen_project', project_dir, context, delete_project_on_failure\n        )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                outdir = env.from_string(outdir).render(**context)\n                logger.debug('Copying dir %s to %s without rendering', indir, outdir)\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir, context, output_dir, env, overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file %s to %s without rendering', infile, outfile\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(\n                        project_dir, infile, context, env, skip_if_file_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    if accept_hooks:\n        _run_hook_from_repo_dir(\n            repo_dir,\n            'post_gen_project',\n            project_dir,\n            context,\n            delete_project_on_failure,\n        )\n\n    return project_dir"
}